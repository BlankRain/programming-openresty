== Preparing Tests

As we have seen in the previous sections, `Test::Nginx` provides a simple
declarative format to express test cases. Each test case is represented
by a test block. A test block consists of a title, an optional description,
and several data sections for specifying inputs and expected outputs. In
this section, we will have a close look at how to prepare such test cases
for different test requirements.

Designing test cases is an art, in many ways. It may, sometimes, take even
more time and effort than implementing the feature to be tested, according
to our own experience. `Test::Nginx` tries hard to make writing tests as
simple as possible but it still cannot automate the whole test case design
process. Only you know exactly what to test and how it can be tested anyway.
This section will focus on the basic primitives provided by `Test::Nginx`
that you can take advantage of to devise clever and effective test cases.

=== Preparing NGINX Configuration

In a test block, we can use different data sections to specify our custom
snippets in different positions of the final `nginx.conf` configuration
file generated by `Test::Nginx`.

The most common one is the `config` section which is used to insert custom
snippets inside the `server {}` configuration block for the default test
server. We can also use the `http_config` section to insert our custom
content into the `http {}` configuration block of `nginx.conf`. The `main_config`
section can be used to insert content into the top-level scope of the NGINX
configuration. Let's consider the following example.

[source,test-base]
----
=== TEST 1:
--- main_config
env MY_ENVIRONMENT;

--- http_config
    init_worker_by_lua_block {
        print("init")
    }

--- config
    location = /t {
        echo ok;
    }

--- request
GET /t
--- response_body
ok
----

This test block will generate an `nginx.conf` file with the following basic
structure:

[source,nginx]
----
...
env MY_ENVIRONMENT;

http {
    ...

    init_worker_by_lua_block {
        print("init")
    }

    server {
        ...

        location = /t {
            echo ok;
        }
    }
}
----

Please pay attention to how the `main_config`, `http_config`, and `config`
data sections' values are mapped into different locations in the NGINX
configuration file.

When in doubt, we can always check out the actual `nginx.conf` file generated
by the test scaffold at the location `t/servroot/conf/nginx.conf` in the
current working directory (usually just being the root directory of the
current project).

`Test::Nginx` generates a new `nginx.conf` file for each test block, which
makes it possible for each test block to become self-contained. By default,
the test scaffold automatically starts a new NGINX server before running
each test block and shuts down the server immediately after running the
block. Fortunately, NGINX is a lightweight server and it is usually very
fast to start and stop. Thus, the test blocks are not that slow to run
as it might look.

=== Preparing Requests

The simplest way to prepare a request is to use the `request` data section,
as in

[source,test-base]
----
--- request
GET /t?a=1&b=2
----

The HTTP/1.1 protocol is used by default. You can explicitly make it use
the HTTP/1.0 protocol if desired:

[source,test-base]
----
--- request
GET /t?a=1&b=2 HTTP/1.0
----

Leading spaces or empty lines in the value of the `request` section are
automatically discarded. You can even add comments by leading them with
a `#` character, as in

[source,test-base]
----
--- request

    # this is a simple test:
    GET /t
----

You can add some additional request headers at the same time through the
`more_headers` section as below.

[source,test-base]
----
--- request
GET /t
--- more_headers
Foo: bar
Bar: baz
----

==== Pipelined Requests

Preparing pipelined HTTP requests are also possible. But you need to use
the `pipelined_requests` section instead of `request`. For instance,

[source,test-base]
----
=== TEST 1: pipelined requests
--- config
    location = /t {
        echo ok;
    }

--- pipelined_requests eval
["GET /t", "GET /t"]

--- request_body eval
["ok", "ok"]
----

It is worth noting that we use the `eval` filter with the `pipelined_requests`
section to treat the literal value of that section as Perl code. This way
we can construct a Perl array of the request strings, which is the expected
data format for the `pipelined_requests` section. Similarly we need a similar
trick for the `response_body` section when checking outputs. With an array
of expected response body data, we can expect and check different values
for different individual request in the pipeline. Note, however, not every
data section supports the same array-typed value semantics as `response_body`.

=== Checking Responses

We have already visited the `response_body` and `error_code` data sections
for checking the response body data and response status code, respectively.

The `response_body` data section always performs an exact whole-string
comparison between the section value and the actual response body. It tries
to be clever when long string value comparison fails. Consider the following
sample output from `prove`.

....
t/foo.t .. 1/?
#   Failed test 'TEST 1: long string test - response_body - response is expected (req 0)'
#   at .../test-nginx/lib/Test/Nginx/Socket.pm line 1282.
#          got: ..."IT 2.x is enabled.\x{0a}\x{0a}"...
#       length: 409
#     expected: ..."IT 2.x is not enabled.\x{0a}"...
#       length: 412
#     strings begin to differ at char 400 (line 1 column 400)
# Looks like you failed 1 test of 2.
/tmp/foo.t .. Dubious, test returned 1 (wstat 256, 0x100)
Failed 1/2 subtests

Test Summary Report
-------------------
/tmp/foo.t (Wstat: 256 Tests: 2 Failed: 1)
  Failed test:  2
  Non-zero exit status: 1
Files=1, Tests=2,  0 wallclock secs (0.01 usr 0.00 sys + 0.09 cusr 0.03 csys = 0.13 CPU)
Result: FAIL
....

From this test report, we can clearly see that

. it is the test block with the title `TEST 1: long string test` that is
failing,
. it is the `response_body` data section check that fails,
. the actual response body data is 409 bytes long while the expected value
is 412 bytes, and
. the expected value has an additional `not` word in the string fragment
`IT 2.x is enabled` and the difference starts at the offset 400 in the
long string.

Behind the scene, `Test::Nginx` uses the Perl module link:https://metacpan.org/pod/Test::LongString[Test::LongString]
to do the long string comparisons. It is also particularly useful while
checking response body data in binary formats.

If your response body data is in a multi-line textual format, then you
may also want to use a `diff`-style output when the data does not match.
To achieve this, we can call the `no_long_string()` Perl function before
the `run_tests()` function call in the prologue part of the test file.
Below is such an example.

....
use Test::Nginx::Socket 'no_plan';

no_long_string();

run_tests();

__DATA__

=== TEST 1:
--- config
    location = /t {
        echo "Life is short.";
        echo "Moon is bright.";
        echo "Sun is shining.";
    }
--- request
GET /t
--- response_body
Life is short.
Moon is deem.
Sun is shining.
....

Note the `no_long_string()` call in the prologue part. It is important
to place it before the `run_tests()` call otherwise it would be too late
for it to take effect, obviously.

Invoking the `prove` utility (or any shell wrappers for it) to run this
test file gives the following details about the test failure:

....
#   Failed test 'TEST 1: - response_body - response is expected (req 0)'
#   at .../test-nginx/lib/Test/Nginx/Socket.pm line 1277.
# @@ -1,3 +1,3 @@
#  Life is short.
# -Moon is deem.
# +Moon is bright.
#  Sun is shining.
# Looks like you failed 1 test of 2.
....

It is obvious that the second line of the response body output is different.

You can even further disable the `diff`-style comparison mode by adding
a `no_diff()` Perl function call in the prologue part. Then the failure
report will look like this:

....
#   Failed test 'TEST 1: - response_body - response is expected (req 0)'
#   at .../test-nginx/lib/Test/Nginx/Socket.pm line 1277.
#          got: 'Life is short.
# Moon is bright.
# Sun is shining.
# '
#     expected: 'Life is short.
# Moon is deem.
# Sun is shining.
# '
# Looks like you failed 1 test of 2.
....

That is, `Test::Nginx` just gives full listing of the actual response body
data and the expected one without any abbreviations or hand-holding.

==== Pattern Matching on Response Bodies

When the request body may change in some ways or you just care about certain
key words in a long data string, you can specify a Perl regular expression
to do a pattern match against the actual request body data. This is achieved
by the `response_body_like` data section. For example,

....
--- response_body_like: age: \d+
....

Be careful when you are using the multi-line data section value form. A
trailing newline character appended to your section value may make your
pattern never match. In this case the `chomp` filter we introduced in an
early section can be very helpful here. For example,

....
--- response_body_like chomp
age: \d+
....

You can also use the `eval` filter to construct a Perl regular expression
object with a Perl expression, as in

....
--- response_body_like eval
qr/age: \d+/
....

This is the most flexible form to specify a pattern.

NOTE: Perl uses the `qr` quoting structure to explicitly construct regular
expression objects. You can use various different quoting forms like `qr/.../`,
`qr!...!`, `qr#...#`, and `qr{...}`.

==== Checking Response Headers

The `response_headers` data section can be used to validate response header
entries. For example,

....
--- response_headers
Foo: bar
Bar: baz
!Blah
....

This section dictates 3 tests actually:

. The response header `Foo` must appear and must take the value `bar`;
. The response header `Bar` must appear and must take the value `baz`;
and
. The response header `Blah` must not appear or take an empty value.

=== Checking NGINX Error Logs

In addition to responses, the NGINX error log file is also an important
output channel for an NGINX server setup.

// TODO
